create first push............................
# Step 0 – cd "C:\Users\BAB AL SAFA\Pictures\Ecommerce"
# This changes your terminal to your project folder. All Git commands will run here.
..................................................................................................
# Step 1 – rmdir /s /q .git

# Deletes the old Git history completely.
# /s → deletes all subfolders inside .git
# /q → quiet mode, no confirmation prompts
# Effect: your repo is “fresh,” Git won’t see any old commits or secrets.
..................................................................................................
# Step 2 – git init

# Initializes a brand-new Git repository in your project folder.
# Creates a new default branch (usually master at first).
# the befor 3rd step run this step for Windows 
# – git config --global core.autocrlf 
# true Fixes the LF vs CRLF warnings you were seeing.
#  Converts line endings automatically between 
#  Windows (CRLF) and Git/Unix (LF).
..................................................................................................
# Step 3 – git branch -M main

# Renames your current branch to main.
# -M = force rename, overwriting if main exists.
# Effect: your default branch is now main, which is the modern standard on GitHub.
..................................................................................................
# Step 4 – Add .gitignore entries

# echo "backend/.env" >> .gitignore
# echo "backend/node_modules/" >> .gitignore
# Tells Git to ignore the real .env file (keeps secrets local) and node_modules/ (big folder, shouldn’t go to GitHub).
# Effect: these files won’t appear in git status and won’t be pushed.
..................................................................................................
# Step 5 – git add .

# # Stages all files for commit.
# # Only files not ignored will be added (e.g., your code, .env.example).
..................................................................................................
# # Step 6 – git commit -m "Initial commit - clean project ready for GitHub"

# # Creates your first commit with a snapshot of your current project.
# # # Step 7 – git remote add origin <repo-url>
# # # Connects your local repository to the GitHub repository.
# # # origin is the name of the remote repo.
..................................................................................................
# # # Step 8 – git push -u origin main --force

# # # Pushes your main branch to GitHub.
# # # --force replaces any old commits in GitHub with your clean history.
# # # -u sets this branch as the default upstream so future git push commands know where to go.
..................................................................................................

 For your 2nd, 3rd, etc., commits......................................................
# # # Step 9 – Subsequent pushes in future working continu with this 
#  git status
#  git add .
#  git commit -m "Descriptive message"
#  git push origin main
# # # You don’t need --force anymore.
# # # Always check .git status / first to make sure no secrets are staged.


# # # ✅ Result of this workflow:

# # # A completely clean GitHub repo with no secret keys.

# # # .env stays local, .env.example is shared.

# # # node_modules/ is ignored.

# # # Default branch is main.
# # # Future pushes are safe and simple.

 creating in brach and working on it ..................................................................................................
 ..................................................................................................
# # Step 1: Make sure you are on main

# # Open your terminal in your project folder:
# # git checkout main

# # This ensures your new branch is created from the latest stable main.
..................................................................................................
# # Step 2: Create a new branch

# # git checkout -b new-feature

# # new-feature = name of your new branch (you can choose any name).

# # -b = creates the branch and switches to it immediately.

# # Your terminal should now show:

# # Switched to a new branch 'new-feature'
..................................................................................................
# # Step 3: Work on the new branch


# # Make your changes, edit files, add new files, etc.

# # Stage and commit your changes:

# # git add .
# # git commit -m "Add some new feature"
..................................................................................................
# # Step 4: Push the new branch to GitHub

# # git push -u origin new-feature

# # -u = sets upstream, so next time you can just type git push.

# # Your new branch now exists on GitHub separately from main.
..................................................................................................
# # Step 5: Keep main safe


# # You can continue working on new-feature without affecting main.

# # main stays clean and stable.

# # When your feature is ready, create a Pull Request on GitHub:

# # new-feature → main

# # After merging, main will have the new changes.
..................................................................................................
# # Step 6: Switch back to main

# # git checkout main

# # Now you can continue working on main or create another branch.

# # ✅ Result

# # main = stable, default branch

# # new-feature = separate branch for your work

# # Can create unlimited branches without touching main

# # Safe workflow for collaborative work or personal projects


 to transfer the change made in brach to main use this steep..................................................................................................
 ..................................................................................................
# 1. Make sure your branch is up to date

# If you’re on your feature branch (e.g., new-feature), first commit all changes:
# git add .
# git commit -m "Finish feature work"
..................................................................................................
# 2. Switch to main

# git checkout main
# You are now on the main branch.
..................................................................................................
# 3. Merge your feature branch into main

# git merge new-feature
# This will apply all changes from new-feature into main.
# If there are conflicts, Git will tell you, and you need to resolve them manually before committing.
..................................................................................................
# 4. Push the updated main branch to GitHub
# git push
# Now GitHub’s main branch has your feature changes.
..................................................................................................
# 5. Switch back to your branch to continue working
# git checkout new-feature

# You are back on your branch.

If you want to update your branch with the latest main changes some chage come from deffernt machin to main with out branch ..................................................................................................

# You’re on your feature branch new-feature.

# Someone else (or you from another machine) pushed changes to main.

# Running:
..................................................................................................
# git pull origin main
..................................................................................................
# will:

# Download the latest commits from GitHub’s main.

# Merge those changes into your current branch (new-feature).

# Your branch now has all updates from main, so it won’t conflict when you eventually merge back.

# ✅ Key point:

# Use this before merging your branch to main or if main has new changes while you’re still working on your branch.

# Keeps your branch up to date and avoids merge conflicts later.

# # # ............................................................
# # # 1️⃣ Product / Payment information (MOST IMPORTANT)

# # # Stripe needs to know what you are charging for.

# # That means:

# # ✅ Price of one item
# # unit_amount: 5000


# # Always in cents

# # $50 → 5000

# # ✅ Currency
# # currency: "usd"

# # ✅ Quantity
# # quantity: 2


# # Stripe calculates:

# # price × quantity

# # 2️⃣ Line items (the cart)

# # Stripe expects products in this format:

# # line_items: [
# #   {
# #     price_data: {
# #       currency: "usd",
# #       product_data: {
# #         name: "Shoes",
# #         images: ["image-url"]
# #       },
# #       unit_amount: 5000
# #     },
# #     quantity: 2
# #   }
# # ]


# # This is basically:

# # What is the product?

# # How much is one?

# # How many?

# # 3️⃣ Payment method

# # Stripe must know how the user will pay:

# # payment_method_types: ["card"]


# # This means:

# # Credit card

# # Debit card

# # (You can add others later like Apple Pay, Google Pay)

# # 4️⃣ Payment mode
# # mode: "payment"


# # Means:

# # One-time payment

# # Other modes exist:

# # subscription

# # setup

# # But for ecommerce → payment ✅

# # 5️⃣ Success & cancel URLs

# # Stripe needs to know where to send the user after payment.

# # success_url: "http://localhost:5173/purchase-success"
# # cancel_url: "http://localhost:5173/purchase-cancel"


# # ✅ Success → payment done

# # ❌ Cancel → user backed out

# # Without these, Stripe won’t work.

# # 6️⃣ Discounts (optional)

# # If you use coupons:

# # discounts: [
# #   { coupon: "stripe_coupon_id" }
# # ]


# # This tells Stripe:

# # “Reduce the total price”

# # Not required, but useful.

# # 7️⃣ Metadata (VERY IMPORTANT for YOU)

# # Stripe does not know your app.

# # So you attach your own data:

# # metadata: {
# #   userId: "123",
# #   couponCode: "GIFT10",
# #   products: "[...]"
# # }


# # This helps you later to:

# # Save order in MongoDB

# # Know who paid

# # Know what they bought

# # Stripe stores this and sends it back in webhooks.

# # 8️⃣ Secret key (from .env)

# # Stripe needs authentication:

# # STRIPE_SECRET_KEY=sk_test_...


# # Frontend (React/Vue/any)
# #         │
# #         │ 1️⃣ User adds products to cart
# #         ▼
# # Backend (Node.js / Express)
# #         │
# #         │ 2️⃣ Receive cart + optional coupon from frontend
# #         │    └─ req.body = { products: [...], couponCode: "GIFT10" }
# #         ▼
# # Calculate totalAmount & prepare lineItems
# #         │
# #         │ 3️⃣ Loop through products:
# #         │       amount = product.price * 100 (cents)
# #         │       totalAmount += amount * quantity
# #         │
# #         │ 4️⃣ Prepare lineItems array for Stripe:
# #         │       [
# #         │         { price_data: { currency, product_data, unit_amount }, quantity },
# #         │         ...
# #         │       ]
# #         │
# #         │ 5️⃣ Apply coupon if exists:
# #         │       - Check in DB: Coupon.findOne(...)
# #         │       - Subtract discount from totalAmount
# #         │       - Create Stripe coupon ID using createStripeCoupon()
# #         │
# #         ▼
# # Create Stripe Checkout Session
# #         │
# #         │ stripe.checkout.sessions.create({
# #         │     payment_method_types: ["card"],
# #         │     line_items: [...],
# #         │     mode: "payment",
# #         │     discounts: [{ coupon: stripeCouponId }],
# #         │     metadata: {
# #         │         userId,
# #         │         couponCode,
# #         │         products: JSON.stringify(productsArray)
# #         │     },
# #         │     success_url: CLIENT_URL/purchase-success?session_id={CHECKOUT_SESSION_ID},
# #         │     cancel_url: CLIENT_URL/purchase-cancel
# #         │ })
# #         ▼
# # Stripe Checkout Page
# #         │
# #         │ 6️⃣ User enters card info and completes payment
# #         ▼
# # Stripe Payment Result
# #         │
# #         │ 7️⃣ Stripe redirects user to success_url or cancel_url
# #         │ 8️⃣ success_url includes session_id in query
# #         ▼
# # Frontend (purchase-success page)
# #         │
# #         │ 9️⃣ Read session_id from URL
# #         │ 10️⃣ Call backend to verify session:
# #         │       stripe.checkout.sessions.retrieve(session_id)
# #         │       → Get session details: total_amount, metadata, discounts, etc.
# #         ▼
# # Backend: Create Order in Database
# #         │
# #         │ 11️⃣ Parse products from metadata
# #         │ 12️⃣ Create new Order:
# #         │       {
# #         │         user: userId,
# #         │         products: [...],
# #         │         totalAmount: session.amount_total / 100,
# #         │         stripeSessionId: session_id
# #         │       }
# #         │ 13️⃣ Save order in DB
# #         ▼
# # Frontend: Show Order Confirmation
# .env
# backend/.env

"backend/.env" 
"backend/node_module/" 
.env

# if still trcked .env do it in step 
# git filter-branch --force --index-filter "git rm --cached --ignore-unmatch .env backend/.env" --prune-empty --tag-name-filter cat -- --all
# git reflog expire --expire=now --all
# git gc --prune=now --aggressive
# git push origin main --force
 
#  git rm --catched backend/.env
#  git commit -m "never trace .env"

